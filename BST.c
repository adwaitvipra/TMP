/*
 * BINARY SEARCH TREE
 */

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<string.h>
#include<limits.h>

typedef struct node{
	int data;
	struct node *left, *right;
}node;

typedef struct{
	node *root;
	int size;
}bst;

//========================================================================================================================================================================
//	DECLARATIONS
//========================================================================================================================================================================

bst *init(void);
node *getNode(int data);
bool isEmpty(bst );
bool isFull(void);
void preOrder(bst );
void preorder(node *);
void inOrder(bst );
void inorder(node *);
void postOrder(bst );
void postorder(node *);
void insert(bst *, int);
node *rInsert(node *, int);
node *search(bst, int);
node *rSearch(node *, int);

void deleteTree(bst *);
void rDeleteTree(node *);
//========================================================================================================================================================================
//	DEFINATIONS
//========================================================================================================================================================================
//========================================================================================================================================================================
//INITIALIZATIONS
//========================================================================================================================================================================

bst *init(void)
{
	bst *newTree = NULL;
	if(!(newTree = (bst *)malloc(sizeof(bst))))
		return NULL;

	newTree->root = NULL;
	newTree->size = 0;

	return newTree;
}

node *getNode(int data)
{
	node *newNode = NULL;
	if(!(newNode = (node *)malloc(sizeof(node))))
		return NULL;

	newNode->data = data;
	newNode->left = newNode->right = NULL;

	return newNode;
}

bool isEmpty(bst tree)
{
	if(!tree.root)
		return true;
	return false;
}
bool isFull(void)
{
	node *tmp = NULL;
	if(!(tmp=(node *)malloc(sizeof(node))))
		return true;
	free(tmp);
	return false;
}

//========================================================================================================================================================================
//TRAVERSAL
//========================================================================================================================================================================

void preOrder(bst tree)
{
	if(isEmpty(tree))
		return;
	
	preorder(tree.root);
	
	return;
}
void preorder(node *root)
{
	if(root)
	{
		printf("%d ", root->data);
		preorder(root->left);
		preorder(root->right);
	}
	return;
}
void inOrder(bst tree)
{
	if(isEmpty(tree))
		return;
	
	inorder(tree.root);
	
	return;
}
void inorder(node *root)
{
	if(root)
	{
		inorder(root->left);
		printf("%d ", root->data);
		inorder(root->right);
	}
	return;
}
void postOrder(bst tree)
{
	if(isEmpty(tree))
		return;
	
	postorder(tree.root);
	
	return;
}
void postorder(node *root)
{
	if(root)
	{
		postorder(root->left);
		postorder(root->right);
		printf("%d ", root->data);
	}
	return;
}


//========================================================================================================================================================================
// INSERTION
//========================================================================================================================================================================

node *rInsert(node *tree, int val)
{
	if(!tree)
	{
		node *newNode = getNode(val);
		return newNode;
	}
	else
	{
		if(tree->data < val)
			tree->right = rInsert(tree->right, val);
		else
			tree->left = rInsert(tree->left, val);
	}
}

void insert(bst *tree, int val)
{
	if(isFull() || search(*tree, val))
		return ;
	tree->root = rInsert(tree->root, val);
	tree->size++;

	return ;
}
//========================================================================================================================================================================
// SEARCH
//========================================================================================================================================================================

node *rSearch(node *tree, int val)
{
	if(!tree || tree->data == val)
		return tree;
	if(tree->data < val)
		rSearch(tree->right, val);
	else
		rSearch(tree->left, val);
}

node *search(bst tree, int val)
{
	if(isEmpty(tree))
		return NULL;
	return rSearch(tree.root, val);
}

//========================================================================================================================================================================
// DELETE
//========================================================================================================================================================================

void deleteTree(bst *ptr)
{
	if(isEmpty(*ptr))
		return ;
	rDeleteTree(ptr->root);
	free(ptr);
	return ;
}
void rDeleteTree(node *root)
{
	if(!root)
		return ;
	
	rDeleteTree(root->left);
	rDeleteTree(root->right);
	if(!root->left && !root->right)
	{
		free(root);
		return ;
	}
}

//========================================================================================================================================================================
//
//========================================================================================================================================================================



//========================================================================================================================================================================
//
//========================================================================================================================================================================



//========================================================================================================================================================================
//
//========================================================================================================================================================================



//========================================================================================================================================================================
//
//========================================================================================================================================================================



//========================================================================================================================================================================
//	DIRVER
//========================================================================================================================================================================

int main(void)
{
	bst *p=NULL;
	p = init();
	for(int i=0; i<100; i++)
		insert(p,rand() % 1000);
	printf("%d = size\n",p->size);
	printf("%d %d\n", p->root->left->data, p->root->right->data);
	preOrder(*p);
	printf("\n\n");
	inOrder(*p);
	printf("\n\n");
	postOrder(*p);
	printf("\n\n");
	deleteTree(p);
	return 0;
}
